import cv2
import os
import numpy as np
from scipy.cluster.vq import *
from sklearn.svm import LinearSVC, NuSVC, SVC
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score as ac
from sklearn.multiclass import OneVsRestClassifier as ovr
from sklearn.multiclass import OneVsOneClassifier as ovo
from sklearn.model_selection import GridSearchCV
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as lda
from matplotlib import pyplot as plt


def get_train_path_list(train_root_path):
    '''
        To get a list of training path directories

        Parameters
        ----------
        train_root_path : str
            Location of training images root directory

        Returns
        -------
        list
            List containing the names of the directories in the
            root directory
    '''

    train_path_list = os.listdir(train_root_path)
    return train_path_list


def get_class_names(train_root_path, train_names):
    '''
        To get a list of training images path and a list of image classes id

        Parameters
        ----------
        train_root_path : str
            Location of training images root directory
        train_names : list
            List containing the names of the training directories

        Returns
        -------
        list
            List containing all image paths in the training directories
        list
            List containing all image classes id
    '''
    image_list = []
    image_class_id = []

    for index, train_class_image in enumerate(train_names):
        image_path_list = os.listdir(train_root_path + '/' + train_class_image)

        for image_path in image_path_list:
            image_list.append(train_root_path + '/' + train_class_image + '/' + image_path)
            image_class_id.append(index)

    return image_list, image_class_id


def create_descriptor_object():
    '''
        To create descriptor object

        Returns
        -------
        object
            Object of chosen descriptor
    '''

    surf = cv2.xfeatures2d.SURF_create()

    return surf


def store_images_description(image_path_list, descriptor_object):
    '''
        To get an image description for each training images using
        chosen descriptor

        Parameters
        ----------
        image_path_list : list
            List containing all image paths in the training directories
        descriptor_object : object
            Object of chosen descriptor

        Returns
        -------
        list
            List containing all training image descriptions
    '''

    descriptor_list = []

    for image in image_path_list:
        _, des = descriptor_object.detectAndCompute(cv2.imread(image), None)
        descriptor_list.append(des)

    return descriptor_list


def stack_image_description(train_description_list):
    '''
        To create a stacked images description

        Parameters
        ----------
        train_description_list : list
            List containing all training image descriptions

        Returns
        -------
        ndarray
            Array containing stacked image descriptions
    '''

    stacked_descriptor = train_description_list[0]

    for descriptor in train_description_list[1:]:
        stacked_descriptor = np.vstack((stacked_descriptor, descriptor))

    stacked_descriptor = np.float32(stacked_descriptor)

    return stacked_descriptor


def k_means_clustering(stacked_descriptors, k=100):
    '''
        Do k-means clustering to the stacked image descriptions to get
        the centroid of the description

        Parameters
        ----------
        stacked_descriptors : ndarray
            List containing stacked image descriptions
        k : int, optional
            The number of centroids to be generated by k-means algorithm
            (default is 100)

        Returns
        -------
        ndarray
            Array containing k centroids generated by k-means algorithm
    '''

    centroids, _ = kmeans(stacked_descriptors, k, 1)

    return centroids


def calculate_histogram_of_features(image_path_list, train_description_list, centroids):
    '''
        To calculate histogram of features for all image descriptions

        Parameters
        ----------
        image_path_list : list
            List containing all image paths in the training directories
        train_description_list : list
            List containing all training image descriptions
        centroids : ndarray
            Array containing k centroids generated by k-means algorithm

        Returns
        -------
        ndarray
            Array containing all histogram of features for all images
    '''

    hist_features = np.zeros((len(image_path_list), len(centroids)), 'float32')

    for i in range(0, len(image_path_list)):
        words, _ = vq(train_description_list[i], centroids)

        for w in words:
            hist_features[i][w] += 1

    return hist_features


def create_standard_scaler_object(histogram_of_features):
    '''
        To create standard scaler object

        Parameters
        ----------
        histogram_of_features : ndarray
            Array containing all histogram of features for all images

        Returns
        -------
        object
            Object of standard scaler
    '''

    standard_scaler = StandardScaler().fit(histogram_of_features)

    return standard_scaler


def normal_distribute(standard_scaler_object, histogram_of_features):
    '''
        To normally distribute the histogram of features

        Parameters
        ----------
        standard_scaler_object : object
            Object of standard scaler
        histogram_of_features : ndarray
            Array containing all histogram of features for all images

        Returns
        -------
        ndarray
            Array containing all histogram of features after being normally
            distributed
    '''

    normalized_hist = standard_scaler_object.transform(histogram_of_features)

    return normalized_hist


def train(normalized_histogram_of_features, image_classes_id):
    '''
        To create and train classifier object

        Parameters
        ----------
        normalized_histogram_of_features : ndarray
            Array containing all histogram of features after being normally
            distributed
        image_classes_id : list
            List containing all image classes id

        Returns
        -------
        object
            Classifier object after being trained with normalized histogram
            of features
    '''
    # param_grid = {'C': [0.001, 0.01, 0.1, 1, 10, 100, 1000],
    #               'gamma': [0.0001, 0.001, 0.01, 0.1],
    #               'kernel': ['linear', 'rbf']}
    #
    # grid_clf = GridSearchCV(SVC(class_weight='balanced'), param_grid, cv=5, iid=False)
    # grid_clf = grid_clf.fit(normalized_histogram_of_features, np.array(image_classes_id))
    #
    # print(grid_clf.best_estimator_)

    # SVC(C=10, cache_size=200, class_weight='balanced', coef0=0.0,
    #     decision_function_shape='ovr', degree=3, gamma=0.1, kernel='rbf',
    #     max_iter=-1, probability=False, random_state=None, shrinking=True,
    #     tol=0.001, verbose=False)

    svc_classifier =SVC(C=10, cache_size=200, class_weight='balanced', coef0=0.0,
                        decision_function_shape='ovr', degree=3, gamma=0.1, kernel='rbf',
                        max_iter=-1, probability=False, random_state=None, shrinking=True,
                        tol=0.001, verbose=False)

    svc_classifier.fit(normalized_histogram_of_features, np.array(image_classes_id))
    svc_classifier.score()

    return svc_classifier


def load_test_image(test_image_path):
    '''
        To load the test image data

        Parameters
        ----------
        test_image_path : str
            Location of test image

        Returns
        -------
        ndarray
            Array containing test image data
    '''

    test_path_list = os.listdir(test_image_path)

    test_image = []

    for image in test_path_list:
        test_image.append(cv2.imread(test_image_path + '/' + image))

    return test_image


def store_test_image_description(test_image, descriptor_object):
    '''
        To get an image description of test images using
        chosen descriptor

        Parameters
        ----------
        test_image : ndarray
            Array containing test image data
        descriptor_object : object
            Object of chosen descriptor

        Returns
        -------
        list
            List containing testing image descriptions
    '''

    descriptor_list = []

    for image in test_image:
        _, des = descriptor_object.detectAndCompute(image, None)
        descriptor_list.append(des)

    return descriptor_list


def calculate_test_histogram_of_features(test_description_list, centroids):
    '''
        Parameters
        ----------
        test_description_list : list
            List containing testing image descriptions
        centroids : ndarray
            Array containing k centroids generated by k-means algorithm

        Returns
        -------
        ndarray
            Array containing all histogram of features from test image
    '''

    hist_features = np.zeros((len(test_description_list), len(centroids)), 'float32')

    for i in range(0, len(test_description_list)):
        words, _ = vq(test_description_list[i], centroids)

        for w in words:
            hist_features[i][w] += 1

    return hist_features


def predict_image(classifier, test_histogram_of_features):
    '''
        To predict the test image with classifier

        Parameters
        ----------
        classifier : object
            Classifier object after being trained with normalized histogram
            of features
        test_histogram_of_features : ndarray
            Array containing all histogram of features from test image
        train_names : list
            List containing the names of image classes available

        Returns
        -------
        str
            Image prediction result of the test image
    '''
    id = classifier.predict(test_histogram_of_features)
    y = np.array([0, 2, 1, 0, 0, 1, 2, 0, 2, 1])
    print(id)
    print(y)
    acc = ac(id, y) * 100
    print('accuracy: ', acc, '%')

    # result = ""
    # for i in classifier.predict(test_histogram_of_features):
    #     if result == "":
    #         result = train_names[i]
    #     else:
    #         result += ',' + train_names[i]
    #
    # return result


def show_result(test_image, prediction_result):
    '''
        Put prediction result text on the test image

        Parameters
        ----------
        test_image : ndarray
            Array containing test image data
        prediction_result : str
            Image prediction result of the test image
    '''

    result = []
    name = ""

    for img in prediction_result:
        if img == ',':
            result.append(name)
            name = ""
        else:
            name += img
    result.append(name)

    for image_id, image in zip(result, test_image):
        cv2.putText(image, image_id, (0, 250), cv2.FONT_HERSHEY_PLAIN, 5, (0, 0, 255), thickness=5)
        cv2.imshow("Result", image)
        cv2.waitKey(0)


'''
You may modify the code below if it's marked between

-------------------
Modifiable
-------------------

and

-------------------
End of modifiable
-------------------
'''
if __name__ == "__main__":
    '''
        Please modify train_root_path value according to the location of
        your data train root directory

        -------------------
        Modifiable
        -------------------
    '''
    train_root_path = "garbage/train"
    '''
        -------------------
        End of modifiable
        -------------------
    '''

    train_names = get_train_path_list(train_root_path)
    image_path_list, image_classes_list = get_class_names(train_root_path, train_names)
    descriptor_object = create_descriptor_object()
    train_description_list = store_images_description(image_path_list, descriptor_object)
    stacked_descriptors = stack_image_description(train_description_list)
    centroids = k_means_clustering(stacked_descriptors)
    histogram_of_features = calculate_histogram_of_features(image_path_list, train_description_list, centroids)
    standard_scaler_object = create_standard_scaler_object(histogram_of_features)
    normalized_histogram_of_features = normal_distribute(standard_scaler_object, histogram_of_features)
    classifier = train(normalized_histogram_of_features, image_classes_list)

    '''
        Please modify test_image_path value according to the location of
        your test image

        -------------------
        Modifiable
        -------------------
    '''
    test_image_path = "garbage/test"
    '''
        -------------------
        End of modifiable
        -------------------
    '''

    test_image = load_test_image(test_image_path)
    test_description_list = store_test_image_description(test_image, descriptor_object)
    test_histogram_of_features = calculate_test_histogram_of_features(test_description_list, centroids)
    test_histogram_of_features = normal_distribute(standard_scaler_object, test_histogram_of_features)
    prediction_result = predict_image(classifier, test_histogram_of_features)
